import ast
import datetime
import logging

import kubernetes
from flask import Flask, request, jsonify
# from openai import OpenAI
from pydantic import BaseModel, ValidationError
import openai
import os, subprocess
import json
from kubernetes import config

# Configs can be set in Configuration class directly or using helper utility
config.load_kube_config()

openai.api_key = os.getenv("OPENAI_API_KEY")

# Configure logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s - %(message)s',
                    filename='agent.log', filemode='a')

app = Flask(__name__)


class QueryResponse(BaseModel):
    query: str
    answer: str


def custom_serializer(obj):
    """Custom serializer for non-serializable objects."""
    if isinstance(obj, datetime.datetime):
        return obj.isoformat()  # Convert datetime to ISO 8601 string
    raise TypeError(f"Type {type(obj)} not serializable")

@app.route('/query', methods=['POST'])
def create_query():
    if openai.api_key:
        logging.info("API key successfully loaded." + openai.api_key)
    else:
        logging.info("API key is missing. Please set the OPENAI_API_KEY environment variable.")

    request_data = request.json
    query = request_data.get('query')

    core_v1 = kubernetes.client.CoreV1Api()
    apps_v1 = kubernetes.client.AppsV1Api()

    all_resources = {}
    try:
        # Get Pods
        pods = core_v1.list_pod_for_all_namespaces()
        all_resources["pods"] = [pod.to_dict() for pod in pods.items]

        # Get Secrets
        secrets = core_v1.list_secret_for_all_namespaces()
        all_resources["secrets"] = [secret.to_dict() for secret in secrets.items]

        # Get ConfigMaps
        configmaps = core_v1.list_config_map_for_all_namespaces()
        all_resources["configmaps"] = [configmap.to_dict() for configmap in configmaps.items]

        # Get Services
        services = core_v1.list_service_for_all_namespaces()
        all_resources["services"] = [service.to_dict() for service in services.items]

        # Get Deployments
        deployments = apps_v1.list_deployment_for_all_namespaces()
        all_resources["deployments"] = [deployment.to_dict() for deployment in deployments.items]

        # Get StatefulSets
        statefulsets = apps_v1.list_stateful_set_for_all_namespaces()
        all_resources["statefulsets"] = [statefulset.to_dict() for statefulset in statefulsets.items]

        # Get DaemonSets
        daemonsets = apps_v1.list_daemon_set_for_all_namespaces()
        all_resources["daemonsets"] = [daemonset.to_dict() for daemonset in daemonsets.items]

        # Get PersistentVolumeClaims (PVCs)
        pvcs = core_v1.list_persistent_volume_claim_for_all_namespaces()
        all_resources["pvcs"] = [pvc.to_dict() for pvc in pvcs.items]

        # Get Events
        events = core_v1.list_event_for_all_namespaces()
        all_resources["events"] = [event.to_dict() for event in events.items]
    except Exception as e:
        logging.info("Error while reading all resources command - " + str(e))
        return jsonify({"error": e}), 500

    with open("/tmp/k8s_resources_all_namespaces.json", "w") as f:
        json.dump(all_resources, f, indent=4, default=custom_serializer)

    # client = OpenAI()
    logging.info("all data - "+str(all_resources))
    datas = {}
    with open("/tmp/k8s_resources_all_namespaces.json", "rb") as file:
        response = openai.File.create(
            file=file,
            purpose="user_data"  # Purpose must align with OpenAI's API usage policies
        )
    file_id = response["id"]
    try:
        messages = [
            {
                "role": "system",
                "content": "You are an ai assistant who will answer questions about various resources deployed in a k8s cluster. You will be given a json file containing details of all k8s resources in all namespaces in the cluster. Answer the query posed by a user based on the provided json files. Since a human is giving the query, you might need to look for resource names which are similar, and not necessarily exactly the provided names. If the query contains a name like mongodb, the actual resource may have an autogenerated id attached to it like mongodb-56c598c8f. Give only one word answers, nothing else in your response."
            },
            {
                "role": "user",
                "content": "Query - {}\nJson file - {}".format(query, file_id)
            }
        ]

        response = openai.chat.completions.create(
            model="gpt-4-turbo",
            messages=messages,

        )
        ret_response = QueryResponse(query=query, answer=response.choices[0].message.content)
        logging.info("Got ret_response: %s", ret_response)
        return jsonify(ret_response.dict())
    except ValidationError as e:
        return jsonify({"error": e.errors()}), 400


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000, debug=True)