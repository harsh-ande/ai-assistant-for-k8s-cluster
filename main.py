import ast
import logging
from flask import Flask, request, jsonify
from openai import OpenAI
from pydantic import BaseModel, ValidationError
import openai
import os, subprocess
import json

openai.api_key = os.getenv("OPENAI_API_KEY")

# Configure logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s - %(message)s',
                    filename='agent.log', filemode='a')

app = Flask(__name__)


class QueryResponse(BaseModel):
    query: str
    answer: str

prep_commands = {
    "all_resources": "kubectl get all -o json -n {}",
    # "pv": "kubectl get pv -o json",
    # "pvc": "kubectl get pvc -o json",
    # "cm": "kubectl get configmap -o json",
    # "crd": "kubectl get crd -o json",
    "secret": "kubectl get secret -o json -n {}",
    "sa": "kubectl get serviceaccount -o json -n {}",
    # "hpa": "kubectl get hpa -o json",
    # "pdb": "kubectl get pdb -o json",
    # "ns": "kubectl get namespaces -o json",
    # "endpoints": "kubectl get endpoints -o json",
    # "statefulset": "kubectl get statefulset -o json"
}


@app.route('/query', methods=['POST'])
def create_query():
    if openai.api_key:
        logging.info("API key successfully loaded." + openai.api_key)
    else:
        logging.info("API key is missing. Please set the OPENAI_API_KEY environment variable.")

    request_data = request.json
    query = request_data.get('query')

    try:
        answer = subprocess.run("kubectl get ns -o json", shell=True, check=True, capture_output=True,
                                text=True).stdout.strip()
        json_ns = ast.literal_eval(answer)
        namespaces = [i["metadata"]["name"] for i in json_ns["items"]]
        logging.info("namespaces list - %s", namespaces)
    except Exception as e:
        logging.info("Error while running command - " + str(e))
        return jsonify({"error": e}), 500

    client = OpenAI()
    for command in prep_commands.keys():
        for ns in namespaces:
            try:
                answer = subprocess.run(prep_commands[command].format(ns), shell=True, check=True, capture_output=True, text=True).stdout.strip()
                # logging.info("all resources - %s", answer)
            except Exception as e:
                logging.info("Error while running command - " + str(e))
                return jsonify({"error": e}), 500

            with open("/tmp/{}_{}.json".format(command, ns), "w") as outfile:
                json.dump(answer, outfile)
            file = client.files.create(file=open("/tmp/{}_{}.json".format(command, ns), "rb"), purpose="fine-tune")

    datas = []
    for command in prep_commands.keys():
        for ns in namespaces:
            with open("/tmp/{}_{}.json".format(command, ns), 'r') as f:
                datas.append(json.load(f))
    # combined_data = {**datas}  # Merge dictionaries
    with open("/tmp/combined_data.json", "w") as outfile:
        json.dump(datas, outfile)
    file = client.files.create(file=open("/tmp/combined_data.json", "rb"), purpose="fine-tune")
    try:
        messages = [
            {
                "role": "system",
                "content": "You are an ai assistant who will answer questions about resources deployed in a k8s cluster. You will be given a json file containing details of all k8s resources in all namespaces in the cluster. Answer the query given by the user based on the data from the provided json files. Since a human is giving the query, you might need to look for resource names which are similar, and not necessarily exactly the provided names. If the query contains a name like mongodb, the actual resource may have an autogenerated id attached to it like mongodb-56c598c8f. Give only one word answers, nothing else in your response."
            },
            {
                "role": "user",
                "content": "Query - {}\nDetails in json format - {}".format(query, file.id)
            }
        ]

        response = openai.chat.completions.create(
            model="gpt-4-turbo",
            messages=messages,

        )
        ret_response = QueryResponse(query=query, answer=response.choices[0].message.content)
        logging.info("Got ret_response: %s", ret_response)
        return jsonify(ret_response.dict())
    except ValidationError as e:
        return jsonify({"error": e.errors()}), 400


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000, debug=True)